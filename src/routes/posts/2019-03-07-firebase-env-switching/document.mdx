## Why do we need multiple envs

To avoid surprises and unintentional changes on production server.

In general, there are 3 envs:

- **Development**: Deploy cloud functions during development.
- **Staging**: Replica of a production environment for software testing.
- **Production**: Production server!

Here is how we use these envs in our development flow 

- Staring working on a new feature, deploy to development server as needed to test cloud functions on env. 
- Then after we complete the feature, we created a PR on GitHub. 
- And when the PR and reviewed and accepted, code will be automatically deploy to Staging env. 
- Then after it's tested on Staging server, we create a Release on GitHub which triggers GitHub action and deploy to Production.

### Why do we need multiple firebase project

Firebase projects actually do support multiple apps, but the support is not complete.

| Service | Multiple Instance Support |
|:----|----:|
|Realtime database| Supported |
|Storage| Supported |
|Hosting| Supported |
|Authentication| Not Supported |
|FireStore| Not Supported |
|Cloud Function| Not Supported |
|Analytics| Not Supported |
|...| Not Supported |

Most features/services does not support multiple instance, even for ones that do, which env is hard and error prone.

And fortunately, [firebase-tools](https://github.com/firebase/firebase-tools) does support multiple firebase projects via `firebase use`.

# How

## Setup

- Create Dev project in console.firebase.google.com
- Enable appropriate services in console (e.g. FireStore, Storage, Functions, Hosting. It need to be enabled first before deploy.)
- Setup local folder with `firebase init`
- Create projects for other envs
- Enable appropriate services in console for other envs (Unfortunately, we can automate this process yet).
- Add to local folder with `firebase use --add`
- Deploy to these envs.

## Cloud Functions

Cloud functions has env setup covered on its own, so you don't need to worry about it in your code.
 
But it might need different env variable.

For example, when integrating with stripe, we usually use test toke for (dev, optionally staging).

Which we can use https://firebase.google.com/docs/functions/config-env

```bash
firebase use dev
firebase functions:config:set strip.key="THE TEST KEY"
firebase use staging
firebase functions:config:set strip.key="THE PRODUCTION KEY"
firebase use production
firebase functions:config:set strip.key="THE PRODUCTION KEY"
``` 

For other identical envs, you can use clone

```bash
firebase use staging
firebase functions:config:clone --from dev
```

## Native app

For iOS:

- there is `GoogleService-Info.plist`
- and `Info.plist` to use the `REVERSED_CLIENT_ID` from `GoogleService-Info.plist` 

For android:

- there is `google-services.json`.
- (Optional) `build.gradle` or `gradle.property`. 

We have some options on how we can approach multiple envs setup.

#### Using multiple targets for iOS

Duplicate `app` target to create `app-staging` and `app-production`, then add there corresponding to their target.

This approach does not require any file swapping, but multiple targets introduces other problems:

1. `react-native link` will only link with the first target. And with manually linking we often forget staging and prod.
1. Native code will need to be added to all the targets, even though with react-native we hardly need to write any native code.

#### Using different Bundle ID

If we use different bundle id for different envs. We can install multiple apps at one device, and not having to worry about they interfering with each other.

But it also require us to config and provisioning them separately.

<hr/>

So in our projects we usually use the same bundle ID with one target for iOS app, and swap out these files. 

Which will require following code in `AppDelegate`:

```swift
let projectKey = "com.mercy.projectKey"
let savedProjectID = UserDefaults.standard.string(forKey: projectKey)

let projectID = Bundle.main.path(forResource: "GoogleService-Info", ofType: "plist")
    .flatMap({ NSDictionary(contentsOfFile:$0) })
    .flatMap({ $0["PROJECT_ID"] as? String})

if savedProjectID != projectID {
    try? Auth.auth().signOut()
    UserDefaults.standard.set(projectID, forKey: projectKey)
    UserDefaults.standard.synchronize()
}
```

Above code check for two cases:

1. Switch firebase env, we would signOut user because they are on different backend.
1. firebase persist auth info in keychain, which will remain after app remove and reinstall. For us this is a feature that we do not want. So since `com.mercy.projectKey` is saved in `NSUserDefaults`, it will log us out when reinstall.

And for file swapping, we have [this](https://gist.github.com/zhigang1992/6e28de154cd8104ef08b9264d4364ee4)

Essentially, it does this:

```typescript
await run(`../node_modules/.bin/firebase use ${env}`);
await run(
`ln -f ./configs/${env}/GoogleService-Info.plist ../app/ios/GoogleService-Info.plist`
);
await run(
`ln -f ./configs/${env}/google-services.json ../app/android/app/google-services.json`
);
await run(
`ln -f ./configs/${env}/Info.plist ../app/ios/mercy/Info.plist`
);
```

The reason why we use `ln` instead of `copy` because it will sync back changes from Xcode or Android Studio.

## Website (With firebase Hosting)

When setup Web project for firebase, we usually got this from firebase

```html
<script src="https://www.gstatic.com/firebasejs/5.8.6/firebase.js"></script>
<script>
  // Initialize Firebase
  var config = {
    apiKey: "AIzaSyD9N6fIvtG-wnjjtGGmaGgBMA56te6kiok",
    authDomain: "mercy-b94dd.firebaseapp.com",
    databaseURL: "https://mercy-b94dd.firebaseio.com",
    projectId: "mercy-b94dd",
    storageBucket: "mercy-b94dd.appspot.com",
    messagingSenderId: "771295960232"
  };
  firebase.initializeApp(config);
</script>
```

But it became a problem when we use different configs on different envs.

Fortunately, firebase provide [reserved urls](https://firebase.google.com/docs/hosting/reserved-urls#sdk_auto-configuration)

```html
<script src="/__/firebase/init.js"></script>
```

or 

```js
fetch('/__/firebase/init.json').then(response => {
  firebase.initializeApp(response.json());
});
```

Then for local development with create-react-app, we use [proxy](https://facebook.github.io/create-react-app/docs/proxying-api-requests-in-development)

```json{3}
{
  ...
  "proxy": "http://mercy-dev.firebaseapp.com",
  ...
}
```

## Firebase Admin Scripts

Through a project's lifecycle, we often need a lot of scripts to certain work.

For example, promoting admin, migrate database, calculating stats.

If we have multiple env, this becoming harder to maintain.

[Here is code](https://gist.github.com/zhigang1992/88dfa42117c9d12b5689e26451a58223)

```typescript{2}
export const currentEnv = (): Env => {
  return process.env.DEPOLY_TO || projectsMap[execSync(`firebase use`).trim()]
};
```

This way, it will use whatever we chose before with `firebase use` by default.
But we still can do `DEPLOY_TO=prod ./scriptA.ts` to overwrite this behavior.

